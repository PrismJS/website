<!DOCTYPE html>
<html lang="en">
<head>

<script>
	// Just a lil’ script to show off that inline JS gets highlighted
	window.console && console.log('foo');
</script>
<meta charset="utf-8" />
<title>Prism</title>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="prism.css" data-noprefix />
<script src="../prefixfree/prefixfree.min.js"></script>

</head>
<body>

<header><div class="wrapper">
	<div class="intro">
		<h1><img src="logo.svg" alt="Prism" /></h1>
	
		<p>
			Prism is a new elegant, robust and lightweight syntax highlighter, built with modern web standards in mind.
		 	It’s a spin-off project from the popular code playground <a href="http://dabblet.com">Dabblet</a> and is extensively tested there daily by thousands of users.
		</p>
	</div>
	 
	<p class="download">
		<a href="" class="full-script">Download Prism</a>
		or <a href="#download">customize your download</a> to include only the languages you need and the compression level you prefer.
	</p>
	
	<ul id="features">
		<li>
			<strong>Incredibly lightweight</strong>
			Only 1KB minified &amp; gzipped (core)
		</li>
		<li>
			<strong>Blazing fast</strong>
			Supports parallelism with Web Workers, if available.
		</li>
		<li>
			<strong>Very extensible</strong>
			Plugin architecture, very easy to define new languages
		</li>
		<li>
			<strong>Easily themeable</strong>
			All styling is done through CSS, with sensible class names
		</li>
	</ul>
	
	
</div></header>

<section id="features-full">
	<h1>Full list of features</h1>
	<ul>
		<li><strong>Only 1KB</strong> minified &amp; gzipped (core). Each language definition adds roughly 300-500 bytes.</li>
		<li>Supports <strong>parallelism with Web Workers</strong>, if available. Disabled by default.</li>
		<li>Very easy to extend without modifying the code, due to Prism’s <a href="#plugins">plugin architecture</a>. Multiple hooks are scattered throughout the source.</li>
		<li>Very easy to <a href="#language-definitions">define new languages</a>. Only thing you need is a good understanding of regular expressions</li>
		<li>All styling is done through CSS, with sensible class names rather than ugly namespaced abbreviated nonsense.</li>
		<li>Wide browser support: IE8+, Firefox, Chrome, Safari, Opera, most Mobile browsers</li>
	</ul>
</section>

<section id="limitations">
	<h1>Limitations</h1>
	<ul>
		<li>Any pre-existing HTML in the code will be stripped off</li>
	</ul>
</section>

<section id="examples">
	<h1>Examples</h1>
	<p>The Prism source, highlighted with Prism (don’t you just love how meta this is?):</p>
	<pre data-src="prism.js"></pre>
	
	<p>This page’s CSS code, highlighted with Prism:</p>
	<pre data-src="style.css"></pre>
	
	<p>This page’s HTML, highlighted with Prism:</p>
	<pre data-src="index.html"></pre>
	
	<p>This page’s logo (SVG), highlighted with Prism:</p>
	<pre data-src="logo.svg"></pre>
	
	<p>If you’re still not sold, you can <a href="examples.html">view more examples</a>.</p>
</section>

<section id="basic-usage">
	<h1>Basic usage</h1>
	
	<p>You will need to include the <code>prism.css</code> and <code>prism.js</code> files you downloaded in your page. Include the CSS file by putting this code on your <code class="prism language-markup">&lt;head></code> element:
	<pre class="prism"><code class="language-markup">&lt;link href="prism.css" rel="stylesheet" /></code></pre>
	
	<p>To include the JavaScript file add this code somewhere in your HTML document, preferably at the bottom, right before the closing <code class="prism language-markup">&lt;/body></code> tag:
	<pre class="prism"><code class="language-markup">&lt;script src="prism.js">&lt;/script></code></pre>
	
	<p>Then, you need to add two CSS classes to any element you want to be automatically processed by Prism: <code>prism</code> and <code>language-xxxx</code> where <code>xxxx</code> is the language of the code.
	The class name <code>language-xxxx</code> is actually the W3C recommended way to <a href="http://www.w3.org/TR/html5/the-code-element.html#the-code-element">declare code languages</a>.
	For example:
	<pre class="prism"><code class="language-markup">&lt;code class="prism language-css">* { margin: 0; }&lt;/code></code></pre>
	
	<p>If you are following the recommended way of presenting code blocks and using a <code>&lt;pre></code> with a <code>&lt;code></code> inside it, you will get better visual results by applying the <code class="prism language-css">.prism</code> class to the <code class="prism language-markup">&lt;pre></code>, like so:</p>
	<pre class="prism"><code class="language-markup">&lt;pre class="prism">&lt;code class="language-css">* { margin: 0; }&lt;/code>&lt;pre></code></pre>
	
	<p>The <code>prism</code> class is not required if you plan to manually call <code class="prism language-javascript">Prism.highlight()</code> on the element and neither is the <code>language-xxxx</code> class if you plan to manually call <code class="prism language-javascript">Prism.tokenize()</code>. 
	To learn how these methods work, refer to the <a href="#api">API Documentation</a> section. However, the <code>.prism</code> class will add some nice styling to the code block.
</p>
</section>

<section id="language-definitions">
	<h1>Language definitions</h1>
	
	<p>Every language is defined as a set of tokens, which are expressed as regular expressions. For example, this is the language definition for CSS:</p>
	<pre data-src="components/prism-css.js"></pre>
	
	<p>A regular expression literal is the simplest way to express a token. An alternative way, with more options, is by using an object literal. With that notation, the regular expression describing the token would be the <code>pattern</code> attribute:</p>
	<pre class="prism"><code class="language-javascript">...
'tokenname': {
	pattern: /regex/
}
...</code></pre>
	<p>So far the functionality is exactly the same between the short and extended notations. However, the extended notation allows for additional options:</p>
	
	<dl>
		<dt>inside</dt>
		<dd>This property accepts another object literal, with tokens that are allowed to be nested in this token. 
		This makes it easier to define certain languages. However, keep in mind that they’re slower and if coded poorly, can even result in infinite recursion.
		For an example of nested tokens, check out the Markup language definition:
		<pre data-src="components/prism-markup.js"></pre></dd>
		
		<dt>lookbehind</dt>
		<dd>This option mitigates JavaScript’s lack of lookbehind. When set to <code class="prism language-javascript">true</code>, 
		the first capturing group in the regex <code>pattern</code> is discarded when matching this token, so it effectively behaves 
		as if it was lookbehind.</dd>
		
		<dt>rest</dt>
		<dd>Accepts an object literal with tokens and appends them to the end of the current object literal. Useful for referring to tokens defined elsewhere. For an example where <code>rest</code> is useful, check the Markup definitions above.</dd>
	</dl>
	
 	<p>Unless explicitly allowed through the <code>inside</code> property, each token cannot contain other tokens, so their order is significant. Although per the ECMAScript specification, objects are not required to have a specific ordering of their properties, in practice they do in every modern browser.</p>
</section>

<section id="api">
	<h1>API documentation</h1>
	
	<section>
		<h1><code>Prism.highlightAll(useWorkers, callback)</code></h1>
		<p>This is the most high-level function in Prism’s API. It fetches all the elements that have the <code>prism</code> class 
		and then calls <code>Prism.highlight()</code> on each one of them.</p>
	
		<h2>Parameters</h2>
		<dl>
			<dt>useWorkers</dt>
			<dd>Whether to use Web Workers to improve performance and avoid blocking the UI when highlighting very large chunks of code. False by default.</dd>
			<dt>callback</dt>
			<dd>An optional callback to be invoked after the highlighting is done. Mostly useful when <code>useWorkers</code> is true, since in that case, the highlighting is done asynchronously.</dd>
		</dl>
	</section>
	
	<section>
		<h1><code>Prism.highlight(element, useWorkers, callback)</code></h1>
		<p>Highlights the code inside a single element. The <code>prism</code> class is not required when invoking this method directly.</p>
		
		<h2>Parameters</h2>
		<dl>
			<dt>element</dt>
			<dd>The element containing the code. It must have a class of <code>language-xxx</code> to be processed, where <code>xxxx</code> is a valid language.</dd>
			<dt>useWorkers</dt>
			<dt>callback</dt>
			<dd>Same as <code>Prism.highlightAll()</code></dd>
		</dl>
	</section>
	
	<section>
		<h1><code>Prism.tokenize(text, tokens)</code></h1>
		<p>This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input and the tokens to use, and returns a string with the HTML produced. When the language definition includes nested tokens, the function is called recursively on each of these tokens.</p>
		
		<h2>Parameters</h2>
		<dl>
			<dt>text</dt>
			<dd>A string with the code to be highlighted.</dd>
			<dt>tokens</dt>
			<dd>An object containing the tokens to use. Usually a language definition like <code>Prism.languages.html</code></dd>
		</dl>
	</section>
</section>

<section id="plugins">
	<h1>Plugins</h1>
	<p>Plugins are additional scripts (and CSS code) that extends Prism’s functionality. Many of the following plugins are official, but are released as plugins to keep the Prism Core small for those who don’t need the extra functionality.</p>
	<ul>
		<li><a href="plugins/line-highlight/">Line highlight: Highlight specific lines and line ranges</a></li>
	</ul>
	
	<p>Did you write a plugin for Prism that you want added to this list? Send a pull request!</p>
</section>

<section id="writing-plugins">
	<h1>Writing plugins</h1>
	
	<p>Prism’s plugin architecture is fairly simple. To add a callback, you use <code class="prism language-javascript">Prism.hooks.add(hookname, callback)</code>. 
	<code>hookname</code> is a string with the hook id, that uniquely identifies the hook your code should run at.
	<code>callback</code> is a function that accepts one parameter: an object with various variables that can be modified, since objects in JavaScript are passed by reference.
	For example, here’s a plugin that enchances HTML/XML entities to include a tooltip that shows the actual character:
	<pre class="prism"><code class="language-javascript">Prism.hooks.add('wrap', function(env) {
	if (env.token === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;amp;/, '&amp;');
	}
});</code></pre>
</section>

<section id="download">
	<h1>Download</h1>
</section>

<section id="credits">
	<h1>Credits</h1>
	<ul>
		<li>To <a href="http://twitter.com/kizmarh">Roman Komarov</a> for his contributions, feedback and testing.</li>
		<li>To <a href="https://twitter.com/zdfs">Zachary Forrest</a> for <a href="https://twitter.com/zdfs/statuses/217834980871639041">coming up with the name “Prism”</a></li>
		<li>To <a href="http://stellarr.deviantart.com/">stellarr</a> for the <a href="http://stellarr.deviantart.com/art/Spectra-Wallpaper-Pack-97785901?q=gallery%3Astellarr%2F185512&qo=2">spectrum background</a> used on this page</li>
		<li>To <a href="https://twitter.com/thecodezombie">Jason Hobbs</a> for <a href="https://twitter.com/thecodezombie/status/217663703825399809">encouraging me</a> to release this script as standalone</li>
	</ul>
</section>

<footer><div class="wrapper">
	<p>Handcrafted with love, by Lea Verou</p>
</div></footer>

<script src="prism.js"></script>
<script src="utopia.js"></script>
<script src="code.js"></script>

</body>
</html>