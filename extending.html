<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf-8" />
<title>Extending Prism ▲ Prism</title>
<link rel="stylesheet" href="style.css" />
<link rel="stylesheet" href="prism.css" data-noprefix />
<script src="../prefixfree/prefixfree.min.js"></script>

</head>
<body>

<header>
	<div class="intro" data-src="templates/header-main.html" data-type="text/html"></div>
	
	<h2>Extending Prism</h2>
	<p>Prism is awesome out of the box, but it’s even awesomer when it’s customized to your own needs. This section will help you write new language definitions, plugins and all-around Prism hacking.</p>
</header>

<section id="language-definitions">
	<h1>Language definitions</h1>
	
	<p>Every language is defined as a set of tokens, which are expressed as regular expressions. For example, this is the language definition for CSS:</p>
	<pre data-src="components/prism-css.js"></pre>
	
	<p>A regular expression literal is the simplest way to express a token. An alternative way, with more options, is by using an object literal. With that notation, the regular expression describing the token would be the <code>pattern</code> attribute:</p>
	<pre class="prism"><code class="language-javascript">...
'tokenname': {
	pattern: /regex/
}
...</code></pre>
	<p>So far the functionality is exactly the same between the short and extended notations. However, the extended notation allows for additional options:</p>
	
	<dl>
		<dt>inside</dt>
		<dd>This property accepts another object literal, with tokens that are allowed to be nested in this token. 
		This makes it easier to define certain languages. However, keep in mind that they’re slower and if coded poorly, can even result in infinite recursion.
		For an example of nested tokens, check out the Markup language definition:
		<pre data-src="components/prism-markup.js"></pre></dd>
		
		<dt>lookbehind</dt>
		<dd>This option mitigates JavaScript’s lack of lookbehind. When set to <code class="prism language-javascript">true</code>, 
		the first capturing group in the regex <code>pattern</code> is discarded when matching this token, so it effectively behaves 
		as if it was lookbehind.</dd>
		
		<dt>rest</dt>
		<dd>Accepts an object literal with tokens and appends them to the end of the current object literal. Useful for referring to tokens defined elsewhere. For an example where <code>rest</code> is useful, check the Markup definitions above.</dd>
	</dl>
	
 	<p>Unless explicitly allowed through the <code>inside</code> property, each token cannot contain other tokens, so their order is significant. Although per the ECMAScript specification, objects are not required to have a specific ordering of their properties, in practice they do in every modern browser.</p>
</section>

<section id="writing-plugins">
	<h1>Writing plugins</h1>
	
	<p>Prism’s plugin architecture is fairly simple. To add a callback, you use <code class="prism language-javascript">Prism.hooks.add(hookname, callback)</code>. 
	<code>hookname</code> is a string with the hook id, that uniquely identifies the hook your code should run at.
	<code>callback</code> is a function that accepts one parameter: an object with various variables that can be modified, since objects in JavaScript are passed by reference.
	For example, here’s a plugin that enchances HTML/XML entities to include a tooltip that shows the actual character:
	<pre class="prism"><code class="language-javascript">Prism.hooks.add('wrap', function(env) {
	if (env.token === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;amp;/, '&amp;');
	}
});</code></pre>
</section>

<section id="api">
	<h1>API documentation</h1>
	
	<section>
		<h1><code>Prism.highlightAll(async, callback)</code></h1>
		<p>This is the most high-level function in Prism’s API. It fetches all the elements that have the <code>prism</code> class 
		and then calls <code>Prism.highlightElement()</code> on each one of them.</p>
	
		<h2>Parameters</h2>
		<dl>
			<dt>async</dt>
			<dd>Whether to use Web Workers to improve performance and avoid blocking the UI when highlighting very large chunks of code. False by default.</dd>
			<dt>callback</dt>
			<dd>An optional callback to be invoked after the highlighting is done. Mostly useful when <code>async</code> is true, since in that case, the highlighting is done asynchronously.</dd>
		</dl>
	</section>
	
	<section>
		<h1><code>Prism.highlightElement(element, async, callback)</code></h1>
		<p>Highlights the code inside a single element. The <code>prism</code> class is not required when invoking this method directly.</p>
		
		<h2>Parameters</h2>
		<dl>
			<dt>element</dt>
			<dd>The element containing the code. It must have a class of <code>language-xxx</code> to be processed, where <code>xxxx</code> is a valid language.</dd>
			<dt>async</dt>
			<dt>callback</dt>
			<dd>Same as in <code>Prism.highlightAll()</code></dd>
		</dl>
	</section>
	
	<section>
		<h1><code>Prism.highlight(text, grammar)</code></h1>
		<p>Low-level function, only use if you know what you’re doing.
		It accepts a string of text as input and the language definitions to use, and returns a string with the HTML produced.</p>
		
		<h2>Parameters</h2>
		<dl>
			<dt>text</dt>
			<dd>A string with the code to be highlighted.</dd>
			<dt>grammar</dt>
			<dd>An object containing the tokens to use. Usually a language definition like <code>Prism.languages.html</code></dd>
		</dl>
		
		<h2>Returns</h2>
		<p>The highlighted HTML</p>
	</section>
	
	<section>
		<h1><code>Prism.tokenize(text, grammar)</code></h1>
		<p>This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input and the language definitions to use, and returns an array with the tokenized code.
		When the language definition includes nested tokens, the function is called recursively on each of these tokens. This method could be useful in other contexts as well, as a very crude parser.</p>
		
		<h2>Parameters</h2>
		<dl>
			<dt>text</dt>
			<dd>A string with the code to be highlighted.</dd>
			<dt>grammar</dt>
			<dd>An object containing the tokens to use. Usually a language definition like <code>Prism.languages.html</code></dd>
		</dl>
		
		<h2>Returns</h2>
		<p>An array of strings, tokens (class Prism.Token) and other arrays.</p>
	</section>
</section>

<footer data-src="templates/footer.html" data-type="text/html"></footer>

<script src="prism.js"></script>
<script src="utopia.js"></script>
<script src="code.js"></script>

</body>
</html>